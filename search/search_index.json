{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\ufeffC++ Library for Responsibility Sensitive Safety Table of contents Introduction License Releases Release 1.x Getting Started Supported Systems Building the library Contributing Introduction This library intends to provide a C++ implementation of the Responsibility Sensitive Safety model (RSS) for Autonomous Vehicles. RSS is described in the following papers. Potential users of this C++ library are encouraged to read these papers in order to become familiar with the concepts and functions provided by the library. On a Formal Model of Safe and Scalable Self-driving Cars, S. Shalev-Shwartz, S. Shammah, A. Shashua, Mobileye, arXiv:1708.06374, https://arxiv.org/abs/1708.06374 Implementing the RSS Model on NHTSA Pre-Crash Scenarios, Mobileye, July 2018, https://www.mobileye.com/responsibility-sensitive-safety/rss_on_nhtsa.pdf The RSS module in this library receives (processed) sensor information as input and provides actuator command restrictions as output. The input to the RSS module is an object list, with information about all objects (road agents) in the surrounding environment of the ego vehicle. For each object, the RSS module creates a description of the object-ego vehicle pair and their properties, called a \"situation\". For each situation, the relevant RSS safety checks are performed and a proper response is calculated. Finally, one overall response is obtained by combining the responses calculated for each object-ego vehicle situation. The resulting actuation command restrictions, in the form of longitudinal and lateral limits on acceleration are provided as output. This library contains a stand-alone C++ implementation of the RSS module. Conversion of AV sensor data to the input object list required by the RSS module is outside the scope of this library. This includes conversion of object location and motion in a Cartesian world coordinate system into a situation based coordinate system. Conversion of the output acceleration restrictions to real AV actuation commands (enforcing the restrictions) is outside the scope of this library. This conversion depends strongly on the software and hardware setup of the actual (or simulated)vehicle. The scope, design and architecture of this C++ library for RSS is described in more detail in the following document packaged with this release. This documentation includes guidance on the usage of the RSS library and its integration into an autonomous driving system. Users of this library are strongly encouraged to read this documentation prior to integration of the library. Usage of ad-rss-lib If you use ad-rss-lib for any publication, please cite the IV'2019 paper: @INPROCEEDINGS{ title={Towards Standardization of AV Safety: C++ Library for Responsibility Sensitive Safety} author={Gassmann, Bernd and Oboril, Fabian and Buerkle, Cornelius and Liu, Shuang and Yan, Shoumeng and Elli, Maria Soledad and Alvarez, Ignacio and Aerrabotu, Naveen and Jaber, Suhel and van Beek, Peter and Iyer, Darshan and Weast, Jack} booktitle={2019 IEEE Intelligent Vehicles Symposium (IV)} year={2019} } Usage with Python Starting with Release v1.6, it is possible to use the ad-rss-lib library also with Python. Please see the Documentation on the Python binding for further information. Usage within CARLA This library can be used together with the open-source driving simulator CARLA to investigate the behavior of RSS. A first version is shown in the following video sequence: Usage within Baidu Apollo In addition, the library is already integrated and used in Baidu's Apollo Open Platform stack : License This software library is provided under the LGPL-2.1 open-source license: https://opensource.org/licenses/LGPL-2.1. In addition, the terms in the following apply: RELEASE NOTES AND DISCLAIMERS . Documentation Visit the project's GitHub page to access the online version of the full documentation of this library. This includes: Doxygen Background documentation . If you have any additional question not answered therein, you might find more in the FAQ Releases General release notes and changes can be found in the Changelog Release 1.x.x The initial release of the C++ software library for RSS implements a subset of the rules and calculations specified in the published RSS paper. This means that this release handles a subset of autonomous driving scenarios, described below. Scenarios other than this subset cannot be handled. Features Limitations This release implements the RSS calculations and rules corresponding to the following scenarios: Multi-lane roads, i.e. longitudinal and lateral safe distance and proper response determination; and Intersections, i.e. two or more routes of different geometry, rules for intersections of routes, with priority/right of way, and longitudinal and lateral proper response determination. However, in the case of intersections, it is assumed that there is always a lateral conflict. The following parts of RSS are NOT implemented in this release of the library software: Unstructured roads, e.g. parking lots and wide round-abouts; Pedestrians, bicyclists and other vulnerable road users; Occlusions; Longitudinal or lateral evasive maneuvers as defined by RSS; and Intersections without a lateral conflict. Note: The RSS module in this library does not initiate evasive manuevers. At the same time, it would not hinder an evasive manuever being executed by the AV driving policy and planning modules, as long as it is compliant with the required RSS proper response. Getting started Installation of dependencies Currently, the focused operating system is Ubuntu 16.04. Nevertheless, the library should work in a similar way for any other Linux OS. To install the dependencies for Ubuntu 16.04 execute the following command: user$ sudo apt-get install git build-essential cmake If you want to use doxygen for API documentation, please also install: user$ sudo apt-get install doxygen graphviz Get the library To download the library, you may run: user$ git clone https://github.com/intel/ad-rss-lib.git user$ cd ad-rss-lib Supported systems Besides Ubuntu 16.04 we are currently supporting the following Linux OS and compiler combinations: Ubuntu 14.04 Ubuntu 16.04 Ubuntu 18.04 Clang 3.4 x Clang 3.8/3.9 x x Clang 5.0 x Clang 6.0 x x GCC 4.8 x GCC 5.4/5.5 x GCC 6.0 x GCC 7.3 x x Important: cmake is required to be at least version 3.5! Building the library Build instructions The RSS library is built with a standard cmake toolchain. Simply run the following commands to build the library: ad_rss$ mkdir build ad_rss$ cd build build$ cmake .. build$ make Unit tests Run the following commands to run the unit-tests: build$ make test API documentation Please run the following command to build the API documentation, if desired: build$ cmake -DBUILD_DOC=1 .. build$ make apidoc Build hardening Usually, build hardening is injected by the surrounding build system. Nevertheless, the CMakeLists.txt defines hardening flags to ensure the code is compatible to respective flags. To enable hardening compiler and linker flags: build$ cmake -DBUILD_HARDENING=1 .. build$ make Contributing Contibutions are very welcome! Before submitting a pull request, please ensure that your code compiles successfully and that the tests run successfully. Please also check that your code formatting complies to the provided clang style. To do so, you can run: ad_rss$ sudo apt-get install clang-format-3.9 ad_rss$ find -iname *.cpp -o -iname *.hpp | xargs clang-format-3.9 -style=file -i This command will automatically update the code formatting to be compliant with our style. In addition, please perform a static code analysis, if possible. ad_rss$ sudo apt-get install clang-tidy ad_rss$ cmake -DBUILD_STATIC_ANALYSIS=ON ad_rss$ make clang-tidy This may provide a list of possible improvements that you would like to consider in your pull request.","title":"Home"},{"location":"#introduction","text":"This library intends to provide a C++ implementation of the Responsibility Sensitive Safety model (RSS) for Autonomous Vehicles. RSS is described in the following papers. Potential users of this C++ library are encouraged to read these papers in order to become familiar with the concepts and functions provided by the library. On a Formal Model of Safe and Scalable Self-driving Cars, S. Shalev-Shwartz, S. Shammah, A. Shashua, Mobileye, arXiv:1708.06374, https://arxiv.org/abs/1708.06374 Implementing the RSS Model on NHTSA Pre-Crash Scenarios, Mobileye, July 2018, https://www.mobileye.com/responsibility-sensitive-safety/rss_on_nhtsa.pdf The RSS module in this library receives (processed) sensor information as input and provides actuator command restrictions as output. The input to the RSS module is an object list, with information about all objects (road agents) in the surrounding environment of the ego vehicle. For each object, the RSS module creates a description of the object-ego vehicle pair and their properties, called a \"situation\". For each situation, the relevant RSS safety checks are performed and a proper response is calculated. Finally, one overall response is obtained by combining the responses calculated for each object-ego vehicle situation. The resulting actuation command restrictions, in the form of longitudinal and lateral limits on acceleration are provided as output. This library contains a stand-alone C++ implementation of the RSS module. Conversion of AV sensor data to the input object list required by the RSS module is outside the scope of this library. This includes conversion of object location and motion in a Cartesian world coordinate system into a situation based coordinate system. Conversion of the output acceleration restrictions to real AV actuation commands (enforcing the restrictions) is outside the scope of this library. This conversion depends strongly on the software and hardware setup of the actual (or simulated)vehicle. The scope, design and architecture of this C++ library for RSS is described in more detail in the following document packaged with this release. This documentation includes guidance on the usage of the RSS library and its integration into an autonomous driving system. Users of this library are strongly encouraged to read this documentation prior to integration of the library.","title":"Introduction "},{"location":"#usage-of-ad-rss-lib","text":"If you use ad-rss-lib for any publication, please cite the IV'2019 paper: @INPROCEEDINGS{ title={Towards Standardization of AV Safety: C++ Library for Responsibility Sensitive Safety} author={Gassmann, Bernd and Oboril, Fabian and Buerkle, Cornelius and Liu, Shuang and Yan, Shoumeng and Elli, Maria Soledad and Alvarez, Ignacio and Aerrabotu, Naveen and Jaber, Suhel and van Beek, Peter and Iyer, Darshan and Weast, Jack} booktitle={2019 IEEE Intelligent Vehicles Symposium (IV)} year={2019} }","title":"Usage of ad-rss-lib"},{"location":"#license","text":"This software library is provided under the LGPL-2.1 open-source license: https://opensource.org/licenses/LGPL-2.1. In addition, the terms in the following apply: RELEASE NOTES AND DISCLAIMERS .","title":"License "},{"location":"#documentation","text":"Visit the project's GitHub page to access the online version of the full documentation of this library. This includes: Doxygen Background documentation . If you have any additional question not answered therein, you might find more in the FAQ","title":"Documentation"},{"location":"#releases","text":"General release notes and changes can be found in the Changelog","title":"Releases "},{"location":"#getting-started","text":"","title":"Getting started "},{"location":"#building-the-library","text":"","title":"Building the library "},{"location":"#contributing","text":"Contibutions are very welcome! Before submitting a pull request, please ensure that your code compiles successfully and that the tests run successfully. Please also check that your code formatting complies to the provided clang style. To do so, you can run: ad_rss$ sudo apt-get install clang-format-3.9 ad_rss$ find -iname *.cpp -o -iname *.hpp | xargs clang-format-3.9 -style=file -i This command will automatically update the code formatting to be compliant with our style. In addition, please perform a static code analysis, if possible. ad_rss$ sudo apt-get install clang-tidy ad_rss$ cmake -DBUILD_STATIC_ANALYSIS=ON ad_rss$ make clang-tidy This may provide a list of possible improvements that you would like to consider in your pull request.","title":"Contributing "},{"location":"CHANGELOG/","text":"Latest changes Maintenance Added ObjectIDVector support to Python binding Release 1.6.0 New Features Added Python binding Release 1.5.0 Maintenance License change to LGPL v2.1 Release 1.4.0 Introduced more straight forward interface on intermediate functions to support better integration of the single calls into an external framework: SituationSnapshot, RssStateSnapshot, ProperResponse. Moved the timeIndex from the individual elements into these high level types to support the propagation of the timeIndex even if there are no other vehicles in the surrounding. Did some renaming (e.g. ResponseState- RssState, ResponseStateVector- RssStateVector, ResponseInformation- RssStateInformation, ResponseEvaluator- RssStateEvaluator) to clarify by naming that the individual calcuated states only consider a snapshot in time without analysis of the dangerous threshold. The ProperResponse became its own type and got an own overall isSafe flag and a list of dangerousObjects. Added ObjectId to Situation and RssState to preserve the mapping to the originating object which was lost with the introduction of multiple situations per object. Increase amount of allowed situations because with multiple situations per object the amount of 100 might be hit too fast. Improved merge of input scenarios to facilitate scene variations of the same situation RssIntersectionChecker: since new situations may pop up when e.g. a previously occluded object is entering the field of view, one cannot guarantee that a previous safe state can be found. In this case, we have to brake instead of returning false. Made some RssState operations available via public interface Add option to select library build type (static/dynamic) Release 1.3.0 Allow multiple situations per ego vehicle/object pair: Add RssSituationIdProvider and made RssSituationExtraction a class holding RssSituationIdProvider instance to keep track of the different situation classes Renamed world::Dynamics in world::RssDynamics, extended it by responseTime and separated it from world::Object; world::Scene got the objectRssDynamics and world::WorldModel the egoVehicleRssDynamics each as separate elements Extended world::Scene by egoVehicle object description as occupied regions and velocity are actually scene dependent (e.g. when considering different vehicle predictions) Added world::ObjectType::Invalid Small updates to be compliant to clang-tidy-3.8 static code analysis Added basic FAQ Added official support for Ubuntu 14.04 (GCC 4.8, Clang 3.4 and 3.8/3.9) Added official support for Ubuntu 18.04 (GCC 7.3) Download/Build gtest on the fly rather than using the version from the OS Fixed documentation of RoadArea LaneSegment ordering (left - right) Fixed isSafe flags of the resolved response Renamed some internal files from 'RSS...' - 'Rss...' to have camel-case everywhere Added ResponseInformation to provide more insight into intermediate result calculation Release 1.2.0 Added support for Clang 5 and Clang 6 Added checks to enforce increasing time indices Consider timeIndex=0 as error Reduced maximum vector input sizes to more feasible numbers (20 lane segments, 50 road segments, 100 scenes) Release 1.1.0 Made generated files and tests more explicit by moving into respective folders Extended documentation Increase test coverage Fixed calculateLateralDimensions() Extended extractSituation() by timeIndex parameter Support for GCC 4.8 Harmonized library and git repo name by renaming ad_rss_lib - ad-rss-lib Release 1.0.0 Initial release","title":"Release Notes"},{"location":"CHANGELOG/#latest-changes","text":"","title":"Latest changes"},{"location":"CHANGELOG/#release-160","text":"","title":"Release 1.6.0"},{"location":"CHANGELOG/#release-150","text":"","title":"Release 1.5.0"},{"location":"CHANGELOG/#release-140","text":"Introduced more straight forward interface on intermediate functions to support better integration of the single calls into an external framework: SituationSnapshot, RssStateSnapshot, ProperResponse. Moved the timeIndex from the individual elements into these high level types to support the propagation of the timeIndex even if there are no other vehicles in the surrounding. Did some renaming (e.g. ResponseState- RssState, ResponseStateVector- RssStateVector, ResponseInformation- RssStateInformation, ResponseEvaluator- RssStateEvaluator) to clarify by naming that the individual calcuated states only consider a snapshot in time without analysis of the dangerous threshold. The ProperResponse became its own type and got an own overall isSafe flag and a list of dangerousObjects. Added ObjectId to Situation and RssState to preserve the mapping to the originating object which was lost with the introduction of multiple situations per object. Increase amount of allowed situations because with multiple situations per object the amount of 100 might be hit too fast. Improved merge of input scenarios to facilitate scene variations of the same situation RssIntersectionChecker: since new situations may pop up when e.g. a previously occluded object is entering the field of view, one cannot guarantee that a previous safe state can be found. In this case, we have to brake instead of returning false. Made some RssState operations available via public interface Add option to select library build type (static/dynamic)","title":"Release 1.4.0"},{"location":"CHANGELOG/#release-130","text":"Allow multiple situations per ego vehicle/object pair: Add RssSituationIdProvider and made RssSituationExtraction a class holding RssSituationIdProvider instance to keep track of the different situation classes Renamed world::Dynamics in world::RssDynamics, extended it by responseTime and separated it from world::Object; world::Scene got the objectRssDynamics and world::WorldModel the egoVehicleRssDynamics each as separate elements Extended world::Scene by egoVehicle object description as occupied regions and velocity are actually scene dependent (e.g. when considering different vehicle predictions) Added world::ObjectType::Invalid Small updates to be compliant to clang-tidy-3.8 static code analysis Added basic FAQ Added official support for Ubuntu 14.04 (GCC 4.8, Clang 3.4 and 3.8/3.9) Added official support for Ubuntu 18.04 (GCC 7.3) Download/Build gtest on the fly rather than using the version from the OS Fixed documentation of RoadArea LaneSegment ordering (left - right) Fixed isSafe flags of the resolved response Renamed some internal files from 'RSS...' - 'Rss...' to have camel-case everywhere Added ResponseInformation to provide more insight into intermediate result calculation","title":"Release 1.3.0"},{"location":"CHANGELOG/#release-120","text":"Added support for Clang 5 and Clang 6 Added checks to enforce increasing time indices Consider timeIndex=0 as error Reduced maximum vector input sizes to more feasible numbers (20 lane segments, 50 road segments, 100 scenes)","title":"Release 1.2.0"},{"location":"CHANGELOG/#release-110","text":"Made generated files and tests more explicit by moving into respective folders Extended documentation Increase test coverage Fixed calculateLateralDimensions() Extended extractSituation() by timeIndex parameter Support for GCC 4.8 Harmonized library and git repo name by renaming ad_rss_lib - ad-rss-lib","title":"Release 1.1.0"},{"location":"CHANGELOG/#release-100","text":"Initial release","title":"Release 1.0.0"},{"location":"FAQ/","text":"FAQ Integrating ad-rss-lib into a system This section tries to give answers to the questions that came up while people were integrating ad-rss-lib into their systems. Integration examples The ad-rss-lib is already integrated in other open source projects: - Apollo Open Platform : In Apollo Open Automated Driving stack RSS is integrated directly into the planning module to provide additional information to be deployed while planning. Classes: RssCheck, RssSituationChecking and RssResponseResolving How can I perform the checks? The ad-rss-lib provides more or less two ways of integrating the functionality into a system. 1. The RssCheck class performs all required steps one after another. Create a permanent object instance of this class and call calculateAccelerationRestriction for every step in time continuously. You have to provide the world model data as input and get the acceleration restrictions to be applied as output. 2. If you are interested in the intermediate results you can to call the processing chain step by step. For this, you have to create a permanent object instance of RssSituationChecking and RssResponseResolving classes and call the following processing chain for every step in time continuously: - RssSituationExtraction::extractSituations(worldModel, situationVector) - mSituationChecking- checkSituations(situationVector, responseStateVector) - mResponseResolving- provideProperResponse(responseStateVector, properResponse) - RssResponseTransformation::transformProperResponse(worldModel, properResponse, accelerationRestriction) You can directly take RssCheck::calculateAccelerationRestriction() as an example on how to call the individual steps. Applying the step-by-step calls especially provides the response state on individual object basis of the scene. Regardless which solution you prefer, you always have to respect the return value of the functions, before you further make use of the information! Why are some functions realized in a namespace where others required a class? The observed situations are analyzed by RSS over time. Therefore, some of the processing steps have to store the state of previous time steps. As a consequence, the object instances of the classes have to exist over time and must not be deleted! Input: world model data The worldModel is the input to the RSS calculations. It is derived from the Sense part. How do I get to the information required for the input worldModel ? The world model data heavily depends on the system the ad-rss-lib is going to be integrated. Therefore, there is no single answer to this question. Simple scenarios can be derived using basic object data, integration of RSS to the full extend demand more sophisticated a-priori information, usually provided by means of an AD-Map. The unit tests provided with the ad-rss-lib build some basic worldModel structures that might be taken as a starting point. Better examples can be found in the section on Integration examples . Output: rssAccelerationRestrictions The rssAccelerationRestrictions is the output of the RSS calculations. It is given as input of the Act part. If a RSS restricted acceleration is applied on the actuators, does it mean that RSS is not only a checker? Yes, indeed. At one hand side RSS performs an analysis of the situation over time which detects if a situation is becoming dangerous. In addition, RSS derives also a proper response for the ego-vehicle on how to get out of such. If finally the resulting acceleration restrictions in longitudinal, lateral left and right directions are considered by the actuation system, the situation will become safe again. Is there any impact on the \"Plan\" part? Should it be adapted since it undergoes RSS acceleration restrictions? There are many possibilities on how the information on the RSS situation analysis can be deployed within a system. It can be used as a plain safety checking and enforcing entity being totally independent from the Plan part. Then, the Plan will only indirectly be influenced in a way, that the vehicle is not following the planing output. But for sure the planning algorithms might directly benefit when feeding back the information from RSS . Even beyond, if the planning algorithms evaluate different driving strategies, RSS can be applied directly within the planning algorithm to influence the rating. This includes also learning algorithms of AI-based planning approaches.","title":"FAQ"},{"location":"FAQ/#faq","text":"","title":"FAQ"},{"location":"FAQ/#integrating-ad-rss-lib-into-a-system","text":"This section tries to give answers to the questions that came up while people were integrating ad-rss-lib into their systems.","title":"Integrating ad-rss-lib into a system"},{"location":"background/Appendix-ParameterDiscussion/","text":"Parameter Discussion The RSS papers uses a few constants required for the safety calculations. The values for these constants are not yet defined and open for discussion/regulation. Nevertheless, the implementation of the ad-rss-lib needs to define initial values for these functions. Note To be as flexible as possible, the parameters are implemented as configuration values so these can be easily adjusted during evaluation or after the release. In other words, the values are not hard coded in the library, but can be changed via the provided inputs. In the following, the key parameters and the decision for possible initial values are discussed. The used parameters based on the RSS paper are: Response time \\rho \\rho It is assumed that an AV vehicle has a shorter response time than a human driver. Therefore, there is a need to have two different parameters. As it might not be possible to determine whether another object is an AV vehicle or has a human driver, the ad-rss-lib will safely assume that all other objects are driven by humans. Hence, two parameters for the response time are used: \\rho_{ego} \\rho_{ego} : for the ego vehicle \\rho_{other} \\rho_{other} : for all other objects Acceleration \\alpha \\alpha RSS proposes several different acceleration/deceleration values. One could argue that acceleration/deceleration differs with the type of vehicle. Also at least the acceleration is dependent on the current vehicle speed. As it cannot be assured that the individual acceleration of each and every car can be known and the specific car can be reliably detected, the ad-rss-lib will assume fixed constants for those values. These could be either the maximum physically possible values or restrictions that are imposed by regulation. Also there will not be different values for the ego vehicle and the other vehicles. It could be argued that for the ego vehicle e.g. desired acceleration might be known. Therefore, a shorter safety distance would be sufficient. But as all other vehicles do not know about the intention of the ego vehicle this would lead to a violation of their safe space. So the ad-rss-lib will need to calculate its checks with the globally defined accelerations values even if the vehicle does not intend to utilize them to its limits. The parameters used for acceleration are: \\alpha_{accel,max} \\alpha_{accel,max} maximum possible acceleration \\alpha_{brake,min} \\alpha_{brake,min} minimum allowed braking deceleration in longitudinal direction for most scenarios \\alpha_{brake,max} \\alpha_{brake,max} maximum allowed deceleration in longitudinal direction \\alpha_{brake,min,correct} \\alpha_{brake,min,correct} minimum allowed deceleration in longitudinal direction for a car on its lane with another car approaching on the same lane in wrong driving direction \\alpha^{lat}_{brake,min} \\alpha^{lat}_{brake,min} minimum allowed braking deceleration in lateral direction \\alpha^{lat}_{accel,max} \\alpha^{lat}_{accel,max} maximum allowed acceleration in lateral direction \\delta^{lat}_{min} \\delta^{lat}_{min} fluctuation margin for that needs to be respected when calculating lateral safe distance Decision on Selected Parameter Values Note The following parameter values are only suggestions and open for discussion. These can be changed at anytime, if it is required. Response time For the response times a common sense value for human drivers is about 2 seconds. For an AV vehicle the response time could be way lower. In order to be not too restrictive the initial value for the ego vehicle response time will be assumed as 1 second. Hence, \\rho_{other} = 2s \\rho_{other} = 2s and \\rho_{ego} = 1s \\rho_{ego} = 1s . If we assume a case of AD vehicles only, the response time may be reduced. Longitudinal Acceleration Finding meaningful acceleration values is more complicated. At the one hand the values should be as close as possible or even exceed the maximum physically possible values. The minimum deceleration values must also not exceed normal human driving behavior. So assuming a too high deceleration for other cars may lead to a false interpretation of the situation. On the other hand a too big difference between the minimum and maximum acceleration values will lead to a very defensive driving style. As a result, participating in dense traffic, will not be possible (see figure below). A rule of thumb for deceleration in German driving schools is: \\alpha_{brake,min} = 4m/s^2 \\alpha_{brake,min} = 4m/s^2 and \\alpha_{brake,max} = 8m/s^2 \\alpha_{brake,max} = 8m/s^2 . But on the other hand, modern cars are able to decelerate with up to 12m/s^2 12m/s^2 . Especially for deceleration, it is questionable whether it is possible and tolerable to restrict maximum braking below physically possible braking force. For the maximum acceleration at low speeds a standard car will be in the range of 3.4m/s^2 3.4m/s^2 to 7m/s^2 7m/s^2 . But there are also sport cars that can go faster than that. But for acceleration a regulation to a maximum value seems to be more likely than for deceleration. Restricting velocity to the current speed limit Required safety distance for cars driving at 50 km/h (city speed) in same direction with \\alpha_{brake,min} = 4m/s^2 \\alpha_{brake,min} = 4m/s^2 and \\alpha_{brake,max} = 8m/s^2 \\alpha_{brake,max} = 8m/s^2 and \\rho_{ego} = \\rho_{other} = 2s \\rho_{ego} = \\rho_{other} = 2s The assumption that a car can always accelerate at \\alpha_{accel,max} \\alpha_{accel,max} during the reponse time, leads to a significant increase of the required safety distance. The figure above shows the required safety distance for different acceleration values. So acceleration about 4m/s^2 4m/s^2 doubles the required safety distance from 40m 40m to about 80m 80m at city speeds. Therefore, it might be advisable to add a restriction that a car is only allowed to accelerate up to the allowed speed limit. In addition, the common behavior (in Germany) is to respect a safety distance of speed/2, e.g. in a city with a speed limit of 50km/h 50km/h the safety distance shall be 25m 25m . Hence, it is obvious that the parameters may require some adjustments to allow reasonable driving. Further possible restrictions Another possibility to decrease the required safety distance to the leading vehicle would be to take the intention of the ego vehicle into account. E.g. if the ego vehicle is following another vehicle and is not intending to accelerate, then there is no need to assume that the ego vehicle is accelerating during its response time. Nevertheless, there are several issues with that approach: It needs to be assured that all intended and unintended accelerations (e.g. driving down a slope) are known to RSS. If RSS formulas are regarded as regulations, the safety distance must be kept regardless to the intent of the vehicle. Therefore, in the current implementation this approach will not be applied. Lateral Acceleration When defining the parameters for lateral acceleration and deceleration, it is import to keep in mind that the definition must allow bypassing of vehicles. Physically high lateral accelerations are possible. In order to be able to bypass a vehicle that is driving on a parallel lane, the safe lateral distance needs to be safe during the complete response time of the other vehicle. Let us consider two identical vehicles driving on the centerline of two adjacent lanes with zero lateral velocity. There is no lateral conflict, if the distance between the border of the car and the adjacent lane is bigger than the distance that the vehicle will cover when accelerating laterally at maximum during its response time and then decelerating to zero lateral velocity. Distance a vehicle will cover when applying the \"Stated Braking Pattern\" with \\rho_{vehicle} = 2s \\rho_{vehicle} = 2s The figure above shows the required safety distance, without considering the fluctuation margin, each car needs to keep to the lane border so the vehicles can pass without lateral conflict. With an assumed minimal lane width of 3 meters and an assumed vehicle width of 2 meters, the distance from vehicle edge to lane border is 0.5 meter, if the car is driving exactly in the middle of the lane. Hence, the required safety distance must be at most 0.5 meter. When using the same values for acceleration and deceleration this will lead to \\alpha^{lat}_{accel,max} 0.1m/s^2 \\alpha^{lat}_{accel,max} < 0.1m/s^2 . But when restricting the acceleration to that value a lane change will take almost 8 seconds. As a result it is advisable, to use a higher deceleration than acceleration to keep the required safety margin and allow for faster lane changes. E.g. \\alpha^{lat}_{brake,min} = 0.8m/s^2 \\alpha^{lat}_{brake,min} = 0.8m/s^2 and \\alpha^{lat}_{accel,max} = 0.2m/s^2 \\alpha^{lat}_{accel,max} = 0.2m/s^2 will fulfill the given safety distance requirement. An increase to higher acceleration values is for the given constraints not possible, as the distance covered during response time is already 0.4 meters. It is obvious that given the lateral safety definition a lane change will at least have a duration of two times the response time. The lateral distance requirement is very strict, therefore it is required to also come up with a desirably small value for the required lateral safety margin \\delta^{lat}_{min} \\delta^{lat}_{min} . As this should only cover for fluctuations, there is also no need for a huge margin. Thus initially this value will be set to \\delta^{lat}_{min} = 10 cm \\delta^{lat}_{min} = 10 cm . This value should be able to cover small fluctuations, but will not have a big impact on the safety distance. Note As a starting point the values are set to: Parameter Value \\rho_{ego} \\rho_{ego} 1s 1s \\rho_{other} \\rho_{other} 2s 2s \\alpha_{accel,max} \\alpha_{accel,max} 3.5m/s^2 3.5m/s^2 \\alpha_{brake,min} \\alpha_{brake,min} 4m/s^2 4m/s^2 \\alpha_{brake,min} \\alpha_{brake,min} 8m/s^2 8m/s^2 \\alpha_{brake,min,correct} \\alpha_{brake,min,correct} 3m/s^2 3m/s^2 \\alpha^{lat}_{brake,min} \\alpha^{lat}_{brake,min} 0.8m/s^2 0.8m/s^2 \\alpha^{lat}_{accel,max} \\alpha^{lat}_{accel,max} 0.2m/s^2 0.2m/s^2 \\delta^{lat}_{min} \\delta^{lat}_{min} 10cm 10cm","title":"Parameter Discussion"},{"location":"background/Appendix-ParameterDiscussion/#parameter-discussion","text":"The RSS papers uses a few constants required for the safety calculations. The values for these constants are not yet defined and open for discussion/regulation. Nevertheless, the implementation of the ad-rss-lib needs to define initial values for these functions. Note To be as flexible as possible, the parameters are implemented as configuration values so these can be easily adjusted during evaluation or after the release. In other words, the values are not hard coded in the library, but can be changed via the provided inputs. In the following, the key parameters and the decision for possible initial values are discussed. The used parameters based on the RSS paper are: Response time \\rho \\rho It is assumed that an AV vehicle has a shorter response time than a human driver. Therefore, there is a need to have two different parameters. As it might not be possible to determine whether another object is an AV vehicle or has a human driver, the ad-rss-lib will safely assume that all other objects are driven by humans. Hence, two parameters for the response time are used: \\rho_{ego} \\rho_{ego} : for the ego vehicle \\rho_{other} \\rho_{other} : for all other objects Acceleration \\alpha \\alpha RSS proposes several different acceleration/deceleration values. One could argue that acceleration/deceleration differs with the type of vehicle. Also at least the acceleration is dependent on the current vehicle speed. As it cannot be assured that the individual acceleration of each and every car can be known and the specific car can be reliably detected, the ad-rss-lib will assume fixed constants for those values. These could be either the maximum physically possible values or restrictions that are imposed by regulation. Also there will not be different values for the ego vehicle and the other vehicles. It could be argued that for the ego vehicle e.g. desired acceleration might be known. Therefore, a shorter safety distance would be sufficient. But as all other vehicles do not know about the intention of the ego vehicle this would lead to a violation of their safe space. So the ad-rss-lib will need to calculate its checks with the globally defined accelerations values even if the vehicle does not intend to utilize them to its limits. The parameters used for acceleration are: \\alpha_{accel,max} \\alpha_{accel,max} maximum possible acceleration \\alpha_{brake,min} \\alpha_{brake,min} minimum allowed braking deceleration in longitudinal direction for most scenarios \\alpha_{brake,max} \\alpha_{brake,max} maximum allowed deceleration in longitudinal direction \\alpha_{brake,min,correct} \\alpha_{brake,min,correct} minimum allowed deceleration in longitudinal direction for a car on its lane with another car approaching on the same lane in wrong driving direction \\alpha^{lat}_{brake,min} \\alpha^{lat}_{brake,min} minimum allowed braking deceleration in lateral direction \\alpha^{lat}_{accel,max} \\alpha^{lat}_{accel,max} maximum allowed acceleration in lateral direction \\delta^{lat}_{min} \\delta^{lat}_{min} fluctuation margin for that needs to be respected when calculating lateral safe distance","title":"Parameter Discussion"},{"location":"background/Appendix-ParameterDiscussion/#decision-on-selected-parameter-values","text":"Note The following parameter values are only suggestions and open for discussion. These can be changed at anytime, if it is required.","title":"Decision on Selected Parameter Values"},{"location":"background/HLD-ArchitectureOverview/","text":"RSS System Architecture Overview This section sketches the integration of RSS into a exisiting system architecture. Overview: Sense, Plan, Act, RSS A generic system architecture for an Automated Driving System From high level view the architecture of an Automated Driving System (ADS) consists of three main parts: Sense, Plan, Act. The world model data provided by the Sense part is used by the Plan part to create the near term actuator control commands executed by the Act part. Integration of RSS into a system architecture RSS is integrated into such an ADS architecture by placing it in parallel to the Plan. To provide a safety envelope around the planning output the integration of RSS into a ADS architecture spans into the Sense part to provide the required RSS world model data as well as into the Act part to limit the actuator control commands to the RSS restrictions. Sense Component The Sense part gathers information on the environment required to fulfill the ADS task. In general there exist several level of perception and fusion which enrich the world model to the extend required for the planning algorithms. In this high-level architecture overview the Sense part takes over this task. SensorSubsystem The SensorSubsystem realizes the Sense part functionality. It is responsible for the perception of the environment. It interfaces to the real world by receiving, processing and fusing sensor information. It provides all information in form of the world model to the other ADS subsystems. The exact content of the world model data is highly dependent on the concrete realization of the receiving subsystems, especially the degree of perception and fusion applied will differ. The provided world model data might include raw sensor data, high level object data, but also a-priori knowledge such as AD map data. To account for this the SensorSubsystem provides separate output ports for every connected subsystem. Port Name Explanation Input None None Output planWorldModelData The world model data required by the PlanningSubsystem rssWorldModelData The world model data required by the RssSubsystem. Extending the Sense part with world model data required by RSS Sense The Sense entity is responsible to create the world model data required by the PlanningSubsystem. This contains the ADS Planning specific implementation of the Sense part which already exists. RssWorldModeling The RssWorldModeling entity is responsible to create the world model data required by the RssSubsystem. The user has to implement this functionality as part of the RSS integration efforts into the ADS system. The RssWorldModelData has to be Plan Component The Plan part processes the information on the environment to create the internal world model required to plan the next moves of the ADS. PlanningSubsystem The PlanningSubsystem realizes the Plan part functionality. It performs the decision-making of the ADS. It analyses the provided PlanWorldModelData and decides what action to take. Finally, this leads to concrete control commands for the ADS ActuatorSubsystem defining the next move of the ADS. Port Name Explanation Input planWorldModelData The world model data required by the PlanningSubsystem Output actuatorControlCommand The control commands to realize the next moves within the current plan Act Component The Act part executes the moves which the Plan part has calculated. ActuatorSubsystem The ActuatorSubsystem realizes the Act part functionality. It receives the ActuatorControlCommands controlling i.e. acceleration, braking and steering to execute the plan. Port Name Explanation Input rssAccelerationRestrictions The restrictions on the acceleration for the vehicle calculated by RSS actuatorControlCommand The control commands to realize the next moves within the current plan Output None None Extending the Act part by RSS command limitation RssActuatorCommandLimitation The RssActuatorCommandLimitation entity receives the actuator control commands from the PlanningSubsystem and restricts the control values according to the restrictions calculated by RSS. The resulting actuator control commands are safe in respect to RSS rules. This calculation heavily depends on the actual representation of the ActuatorControlCommands data. Therefore, a generic implementation is not possible. Therefore, the user has to implement this functionality as part of the RSS integration efforts into the ADS system. Port Name Explanation Input rssAccelerationRestrictions The restrictions on the acceleration for the vehicle calculated by RSS actuatorControlCommandIn The control commands from the PlanningSubsystem to control the vehicle actuator system Output actuatorControlCommandOut The adapted control commands from the PlanningSubsystem to control the vehicle actuator system in a RSS safe manner Act The Act entity is responsible to execute the moves which the PlanningSubsytem has calculated. This contains the ADS actuator specific implementation of the Act part which already exists. Port Name Explanation Input actuatorControlCommand The control commands to control the vehicle actuator system Output None None RSS Component The RSS part restricts the moves the Plan part has calculated according to the RSS proper response RssSubsystem The RssSubsystem realizes the RSS part functionality. It implements the RSS checks based on the RssWorldModelData received from the SensorSubsystem: Keep a safe distance from the car in front Leave time and space for others in lateral maneuvers Exhibit caution in occluded areas [not implemented yet] Right-of-Way is given, not taken In case a dangerous situation is detected a respective proper response is calculated and the actuator control commands received from the PlanningSubsystem are restricted accordingly to realize planning safety. Port Name Explanation Input rssWorldModelData The world model data required to calculate the RSS checks Output rssAccelerationRestrictions The restrictions on the acceleration for the vehicle calculated by RSS RSS internal processing steps to perform RSS checks and execute the RSS proper response RssSituationExtraction The RssSituationExtraction entity transforms the global Cartesian world model data into individual RssSituations between the ego vehicle and each of the objects. For every pair in the world model data the individual situation coordinate system transformation is performed. Port Name Explanation Input rssWorldModelData Global Cartesian world model data providing information on the local surrounding environment required to create the situation coordinate system pairs . Requires local map data (i.e. lane segments and semantics on intersections and priority rules), ego vehicle and object (i.e. position, velocity and RSS dynamics) information. Output rssSituations A list of individual RSS Situations between the ego vehicle and each of the objects. Each situation is formulated within its own lane-based coordinate system. EgoVehicle and Objects: i.e. (relative) position, velocity, priority flag, situation specific RSS acceleration values. RssSituationChecking The RssSituationChecking entity performs the RSS check on all incoming individual RssSituations and creates the required RssResponseStates if dangerous situations are detected. Port Name Explanation Input rssSituations A list of individual RSS Situations between the ego vehicle and each of the objects. Each situation is formulated within its own lane-based coordinate system. EgoVehicle and Objects: i.e. (relative) position, velocity, priority flag, situation specific RSS acceleration values. Output rssResponseStates A list of RSS response states in respect to the individual RSS Situations RssResponseResolving The RssResponseResolving entity handles conflicts of the incoming RssResponseStates. It combines the individual situation specific response states into one single overall RssResponseState. Port Name Explanation Input rssResponseStates A list of RSS response states in respect to the individual RSS Situations Output rssResponseState Resulting combined overall RssResponseState RssResponseTransformation The RssResponseTransformation entity transforms the overall RssResponseState back into the global Cartesian world. This results in RSS restrictions for the actuator commands. Port Name Explanation Input rssResponseState Resulting combined overall RssResponseState provided by the RssResponseResolving Input rssWorldModelData Global Cartesian world model data providing information on the local surrounding environment required to transform the RSS response state back into acceleration restrictions in the Catesian space. Requires local map data (i.e. lane segments of the ego vehicle) and ego vehicle (position, velocity and RSS dynamics) information. Output rssAccelerationRestrictions The resulting restrictions of the actuator control command","title":"System Integration"},{"location":"background/HLD-ArchitectureOverview/#overview-sense-plan-act-rss","text":"A generic system architecture for an Automated Driving System From high level view the architecture of an Automated Driving System (ADS) consists of three main parts: Sense, Plan, Act. The world model data provided by the Sense part is used by the Plan part to create the near term actuator control commands executed by the Act part. Integration of RSS into a system architecture RSS is integrated into such an ADS architecture by placing it in parallel to the Plan. To provide a safety envelope around the planning output the integration of RSS into a ADS architecture spans into the Sense part to provide the required RSS world model data as well as into the Act part to limit the actuator control commands to the RSS restrictions.","title":"Overview: Sense, Plan, Act, RSS"},{"location":"background/HLD-ArchitectureOverview/#sense-component","text":"The Sense part gathers information on the environment required to fulfill the ADS task. In general there exist several level of perception and fusion which enrich the world model to the extend required for the planning algorithms. In this high-level architecture overview the Sense part takes over this task.","title":"Sense Component"},{"location":"background/HLD-ArchitectureOverview/#plan-component","text":"The Plan part processes the information on the environment to create the internal world model required to plan the next moves of the ADS.","title":"Plan Component"},{"location":"background/HLD-ArchitectureOverview/#act-component","text":"The Act part executes the moves which the Plan part has calculated.","title":"Act Component"},{"location":"background/HLD-ArchitectureOverview/#rss-component","text":"The RSS part restricts the moves the Plan part has calculated according to the RSS proper response","title":"RSS Component"},{"location":"background/HLD-KeyDesignDecisionsAndAlternatives/","text":"ad-rss-lib Realization RSS checks and response To check whether the ego vehicle is in a safe state, all the objects in the surrounding must be respected. To do so the ad-rss-lib will perform an analysis against all the objects in the environment individually. Meaning, for each object in the environment the ad-rss-lib will check whether the ego vehicle conflicts with this object. Therefore, longitudinal and lateral checks are performed. As mentioned earlier, these checks are performed separately for each object - ego vehicle pair, i.e. for each situation. At this, the type of situation has to be evaluated upfront outside of this library implementation. Otherwise, this RSS implementation would enforce a concrete representation of the environment and i.e. the map data with lanes, intersections and priority rules. The situations types that have to be identified are: both vehicles drive on the same road in the same direction in opposite direction both vehicles drive on different roads that are connected by an intersection the ego vehicle has priority over the other vehicle the other vehicle has priority over the ego vehicle both vehicles have same priority (no vehicle has priority over the other vehicle) Longitudinal conflicts The behavior for longitudinal conflicts (checks and response) for vehicles driving in the same direction are implemented as described in the definitions 1, 3 and 4 of the RSS paper . For the case of vehicles driving in opposite directions, the implementation follows the definitions 2, 3 and 4 of the paper. In detail, the current realization looks as follows: Same direction If the longitudinal distance is not safe and if the ego vehicle is in front, the other vehicle has to break longitudinally. There is no longitudinal response for the ego vehicle issued. otherwise, the ego vehicle has to break longitudinally with at least \\alpha_{min,brake} \\alpha_{min,brake} . Opposite direction If the longitudinal distance is not safe and if the ego vehicle is driving in the correct direction, the ego vehicle has to break longitudinally with at least \\alpha_{min,brake,correct} \\alpha_{min,brake,correct} . otherwise, the ego vehicle has to break longitudinally with at least \\alpha_{min,brake} \\alpha_{min,brake} . Lateral conflicts The lateral checks and the proper response follow the definitions 5, 6, 7 and 8 of the RSS paper . In detail, the current realization looks as follows: If the lateral distance is not safe and if the ego vehicle is on the left side, the ego vehicle has to break laterally with at least \\alpha^{lat}_{brake,min} \\alpha^{lat}_{brake,min} on the right side if the ego vehicle is on the right side, the ego vehicle has to break laterally with at least \\alpha^{lat}_{brake,min} \\alpha^{lat}_{brake,min} on the left side otherwise, the ego vehicle has to break laterally with at least \\alpha^{lat}_{brake,min} \\alpha^{lat}_{brake,min} on both sides Combining longitudinal and lateral response The combination of longitudinal and lateral response of a single situation (object - ego vehicle pair) is implemented as described in definitions 9 and 10 of the RSS paper . In detail, the current realization looks as follows: If the situation is dangerous (i.e. there exists a longitudinal and a lateral conflict), the stored last non-dangerous state of the of the same situation (ego-vehicle - object pair) is checked: if there was no lateral conflict, the combined response breaks laterally if there was no longitudinal conflict, the combined response breaks longitudinally Combining all situations of a given point in time Since this RSS implementation performs the above mentioned check separately for each situation, the overall response of the ego vehicle has to consider all individual situations of the current scene. The current realization loops over all situations and combines the lateral left, the lateral right and the longitudinal response states of these by selecting the most severe response of each component respectively. Important This initial implementation does not yet cover evasive maneuvers to compensate for improper behavior of others according to definitions 11, 12 and 13 of the RSS paper . If the car finds itself in a dangerous situation one possible action is always to brake. This should always result in a safe state, if both vehicles respond properly according to RSS. Improper behavior of others might still lead to an accident. This is where evasive maneuver could prevent from this. To do so, it must be assured that this lateral movement brings the vehicle into a safe state and does not conflict with another vehicle. In order to determine whether a lateral movement solves the conflict a prediction of the state would be necessary. Such a naive predication following definition 11 of the paper is not available yet in this initial implementation. In addition, the ad-rss-lib currently has no notion of drivable freespace area. Hence, it cannot determine that an evasive maneuver initiated by RSS will cause an accident with an obstacle or forces the vehicle to leave the road. Therefore, it is impossible for the ad-rss-lib in its current form to detect whether a lateral evasion is really feasible. Hence, the ad-rss-lib will not initiate a lateral evasive maneuver according to definitions 12 and 13 of the paper. Instead, it will only restrict the movement in the dangerous direction. Please note that this restriction does not hinder the driving policy to find a better escape for the current situation. If this is the case, for example by braking harder, or changing lanes quicker, RSS will not forbid this maneuver, as long as it does not create another conflict, and is compliant with the restrictions calculated by RSS. Handling of Intersections The behavior for intersection conflicts (checks and response) for vehicles is implemented as described in the definitions 16, 17 and 18 of the RSS paper In detail, the current realization looks as follows: It is checked, if a non-prioritized vehicle was able to stop in front of the intersection. If this is the case, the non-prioritized vehicle is supposed to brake, whereas the prioritized vehicle can continue driving as before. If 1. does not hold, it is checked, if there is a safe longitudinal distance between the two vehicles according to Definition 17.2 of the RSS paper . In this case, the leading vehicle can continue driving, whereas the following vehicle has to respect the \"stated braking pattern\". If 1. and 2. do not hold, there is a time period in which both vehicles may be crossing the intersection. In this case Definition 18.3 of the RSS paper applies, i.e. both cars have to brake laterally and longitudinally with at least \\alpha_{min,brake} \\alpha_{min,brake} . Note Case 1. is the direct realization of Definition 17.1, where it is mentioned that the vehicle was able to stop safely. However, as a consequence, the prioritized vehicle is not forced to brake, if the non-prioritized vehicle does not respect RSS. Since the evasive maneuvers are not yet implemented such kind of improper behavior cannot be handled by the current ad-rss-lib. Important In the current realization of the ad-rss-lib, it is assumed that there is always a lateral conflict in case of intersections. This will be addressed in future. Response Time and Other Parameters According to the papers each traffic participant has a response time, and is objected to respect certain acceleration limits (e.g. maximum acceleration \\alpha_{accel,max} \\alpha_{accel,max} , maximum deceleration \\alpha_{brake,max} \\alpha_{brake,max} , etc.). Within this response time the participants (including the ego vehicle) are allowed to accelerate with at most \\alpha_{accel,max} \\alpha_{accel,max} , and thus increase their velocity. The distance covered during the response time is part of the safe distance, as defined by RSS. Hence, upon entering a dangerous situation, it would be possible to accelerate with up to \\alpha_{accel,max} \\alpha_{accel,max} for at most t response time, as this acceleration is already considered. Note It is important to note that the implementation of the ad-rss-lib in the library only uses parameters, but not the exact value. By this means, the library is independent to changes of the parameter values. Instead, the user defines a feasible parameter set, which is provided as input to the ad-rss-lib. A discussion on the parameter selection can be found in the parameter discussion section . Situation-Based Coordinate System As described in the RSS paper in section 3.2 \"Preliminaries \u2014 A Lane-Based Coordinate System\", all RSS calculations are based on a lane-centric coordinate system. This system uses adjacent, straight lanes of constant width, and thus requires a transformation of the object states from Cartesian into the lane space. This transformation into a lane-based coordinate system is described by a bijective function, as pointed out by paper 1. Therein, the lateral position of a vehicle within the lane is mapped to a parametric interval [ -0.5; 0.5 ], where the lane boundaries are fixed at the borders of the interval. The advantage of such a coordinate system over the Cartesian system is that it allows the direct calculation of longitudinal and lateral distances of objects. However, when transforming the Cartesian space into a lane-based coordinate system, several challenges have to be taken into consideration. Comparing movements in lane-based coordinate systems During the transformation process to a lane-based coordinate system, not only the position but also the the velocities and accelerations have to be transformed. As a matter of fact, the resulting values depend on the actual lane geometry, and thus, velocities and accelerations of different lane-based coordinate systems cannot be compared to each other anymore (ego vehicle - object pair). To illustrate this problems, let us consider the following examples: Discontinuity Problem: Two parallel lanes, different width Figure 1: Two parallel lanes with different width causing a discontinuity in lateral acceleration Let us illustrate this on a simple example with two parallel lanes of different width. Let the left lane A have a constant width of 4 m where the right lane B only has a constant width of 2 m . If both lanes define their own lane-based coordinate system LCS_A LCS_A and LCS_B LCS_B , a Cartesian lateral acceleration value of 1 m/ s^2 s^2 becomes 0.25 lat/ s^2 s^2 in LCS_A LCS_A and 0.5 lat/ s^2 s^2 in LCS_B LCS_B . Therefore, the formula for constant accelerated movement has to use different acceleration constants in different lanes. This situation is getting even worse, if a car is changing the lane from lane A to lane B: then the closed formula for constant accelerated movement to calculate the lateral distance over time cannot be applied anymore directly. Changing Acceleration Problem: Lane is widening/narrowing Figure 2: Changing lane width and its impact on the lateral acceleration Let us consider a lane with changing width in another example. If the lane's width at the beginning is 4 m and 100 m away the lane is narrowing to 2 m . In such a case the Cartesian lateral acceleration value of 1 m/ s^2 s^2 is changing from 0.25 lat/ s^2 s^2 at the beginning towards 0.5 lat/ s^2 s^2 while advancing within the lane. Changing Distances Problem: Lane with a narrow curve Figure 3: Lane describing a narrow 180\u00b0 curve and its impact on driven distances This section illustrates a longitudinal situation similar to the lane widening example. Let us assume the lane has a constant width of 4 m describing a curve with inner radius of 50 m covering 180\u00b0 . The inner border of the lane has a length of about 157.1 m , the center line 163.4 m the outer border 169.7 m . In that situation a longitudinal acceleration value will evaluate to 1.0 lon/ s^2 s^2 for the center line, 0.96 lon/ s^2 s^2 for the outer border and 1.04 lon/ s^2 s^2 for the inner border. Therefore, the longitudinal acceleration changes over time, if the vehicle changes its lateral position within the lane. Summary As sketched in the previous sections both the longitudinal as well as the lateral acceleration values, as well as velocities within the lane-based coordinate system cannot be considered as constant anymore. Moreover, these values do not only change within one coordinate system, but also when changing from one lane-based system to another one. To overcome this issue, we use a \"Situation-Based Coordinate System\" , that is described in detail in the next section. This system is unique for each situation (ego vehicle - object pair) and comprises all lanes required to describe this situation. Chosen Design: Individual Situation-Based Coordinate System As RSS performs a worst case assessment, the idea followed by the ad-rss-lib implementation is to calculate the min/max position values of the vehicles within the situation specific coordinate system. According to the constellation of the vehicles within the situation, the respective worst case lateral and longitudinal border values are selected and processed by the RSS formulas. Like this, it is assured that the calculations are sound, nevertheless this might lead to a more cautious behavior of the vehicle. The following subsections describe the selected approach in more detail. Two parallel lanes, different width As described in the previous section, the border between neighboring lanes of different width introduces discontinuities of the lateral acceleration values (see Figure 1). As the ad-rss-lib judges the relative situation between the ego vehicle and the other objects one by one individually, it is not required to distinguish between the actual lanes within the individual distance calculations. Combining all lanes relevant for the individual situation s_i s_i between ego vehicle and object o_i o_i into one single situation-based coordinate system SCS_i SCS_i resolves all discontinuities, as depicted in Figure 4. Figure 4: Avoid discontinuities by using one single situation-based coordinate system Coming back to the concrete example from Figure 1, left lane A having a constant width of 4 m and right lane B having a constant width of 2 m , both lanes together have a resulting width of 6 m and form an area with continuous lateral acceleration (see also illustration in Figure 4). The check of the ego vehicle with another object o_j o_j which is two lanes at the right of the ego vehicle in a lane C having a constant width of 3 m , has to take all three lanes into account with resulting width of 9 m . Therefore, a different situation-based coordinate system SCS_j SCS_j is required, when checking another object. Lane is widening or has a narrow curve The individual situation specific coordinate system SCS SCS does not yet cover the situations of widening lanes or narrow curves. To take the variation of the lane width and length into account, it is required to apply the extrema within the respective SCS SCS accordingly. Again, coming back to the examples from above, let us have a lane with non constant width between 2 m and 4 m . Then the transformation of the maximal possible lateral position value of the vehicle into the situation coordinate system SCS SCS has to take the maximum width of 4 m into account, while the transformation of the minimal possible lateral position has to be transformed with the minimum width of the lane of 2 m . Like this it is guaranteed that we don't underestimate the distances of the vehicles towards each other. As a result, it is ensured that under all conditions, the safety distances are calculated in a conservative manner. In a similar way, it is possible to transform the longitudinal position values into the situation-based coordinate system SCS_k SCS_k . Note The performed operations can be interpreted as enlarging the vehicles bounding boxes to ensure the worst case is covered. Road area To overcome the problems of discontinuities, changing lateral and longitudinal distances resulting in not comparable velocities and accelerations the situation based coordinate system merges in a first step all lanes segments relevant to the situation (ego vehicle - object pair) into one situation specific metric road area. One can imagine this step as the creation of a bounding box around the two vehicles that is large enough to cover the relevant positions of those while ignoring actual markings on the road between the lanes. By this, especially the physical lateral velocities and accelerations within the Cartesian 2D space of the road area can be measured and calculated straight forward without any discontinuities (see also the illustrations in Figure 5 and Figure 6). Figure 5: Creation of the situation-based coordinate system: The road area (red) consists of all lane segments along the road relevant for the situation between the two vehicles Figure 6: Creation of the situation-based coordinate system: Worst-case transformation of the vehicle bounding box. The metric road on the left leads to transformed vehicles and their bounding boxes (red) on the right, sketched for a narrowing road area at the top and a curve at the bottom. It is worth to mention, that in these calculations the actual shape of the lane is not used. Therefore, detailed knowledge of the actual lane geometry is not required. The absolute maximum and minimum width and length values of the lane segments is sufficient to calculate a proper transformation into the space of the situation specific coordinate systems. Note In case of intersections both vehicles define their own road areas including the intersecting parts. The case that a lane is ending or two lanes are merged into one single lane have to be treated like intersections since a lateral conflict is unavoidable. Considerations on reverse transformation of the proper response As the proper response is referring to the situation-based coordinate systems, the response has to be transformed back considering the actual lane geometry. Therefore, first the transformation into the vehicle-specific lane-based coordinate system is required, and then the transformation into the Cartesian space is performed. A simple example illustrates this: a vehicle driving in a curve will for sure have to perform a lateral acceleration in Cartesian space otherwise it will leave the lane because of the centripetal force, as illustrated in Figure 7. However, in the vehicle specific lane-based system the lateral acceleration will be 0. Figure 7: Constant drive around a curve will result in a zero lateral acceleration in a lane-based coordinate system and in a non-zero acceleration in a cartesian system Because the proper response of RSS is defined with respect to the actual lane the vehicle is driving in, it is required to assure that the reverse transformation of the proper response considers only the ego-lane and not the complete situation specific coordinate systems. For example, let us consider a scenario as depicted in Figure 8, where one widening lane A and one narrowing lane B are neighbors in such a way that the overall width of the road is constantly 6 m . Lane A starts with 2 m and ends with 4 m width, whereas lane B starts with 4 m and ends with 2 m width. A lateral velocity of 0 in respect to the whole road differs from the definition of a lateral velocity of 0 in lane A/lane B in Cartesian space. Figure 8: Different lateral accelerations in a lane-based system and Cartesian system for a vehicle following the centerline of lane B Note It is worth to note that in the particular implementation of the ad-rss-lib in the library at hand, the reverse transformation from the situation-specific into a vehicle-centric lane coordinate system is not required, as the RSS response is defined such that it is independent of these two coordinate system. Summary The presented construction of a continuous situation-based coordinates system will allow the pairwise calculation of the safe distances between ego vehicle and objects with the assumption of constant acceleration. Still, the worst case assessment of RSS is not violated. This situation-based coordinate system in conjunction with the situation specific consideration of the position extrema allows the calculation of the safe distances, the decision on dangerous situations and deduction of a proper response. The main benefits of the selected Situation Based Coordinate System definition are: * Velocity and acceleration values in longitudinal and lateral lane directions do not change when transforming into the situation based coordinate system * All formulas for constant accelerated movement can be applied in the situation based coordinate space. * Distance calculations in situation based coordinate systems are simple additions or subtractions * The transformation into the situation based coordinate system is simple and therefore can be implemented easily with the restricted computational resources of safety controllers For safety considerations, it is crucial to do all calculations considering the worst case assumption. Therefore, it is required to choose the correct minimum or maximum value of the positions in the situation-based coordinate system to assure that always the worst case is considered. Design alternative: Iterative Approach [optional] Figure 9: Illustration of an iterative approach to calculate non-constant acceleration, velocity etc. Another possible way to handle the non-constant acceleration values would be an iterative approach: based on the position, the velocity and the acceleration values at the given position at time t_0 t_0 , the position at time t_1 t_1 is calculated. The smaller the time interval between the iteration steps is chosen, the smaller the calculation error gets (see figure above). One drawback of the iterative approach is that the RSS implementation has to get to know the lane geometries in detail to be able to calculate the acceleration values to be used for every position within the situation-based coordinate systems. Therefore, this design approach is not selected by this ad-rss-lib implementation. Summary Summary RSS checks are performed on the current state on a ego vehicle - object pair basis In dangerous situations only braking maneuvers are issued. RSS does not initiate evasive maneuvers, but will not hinder the driving policy to execute lateral evasive maneuvers, as long as these are compliant with the required RSS response. To handle changing lateral/longitudinal lane geometries when transforming the Cartesian space into the situation based coordinate system, the vehicles position extrema are chosen in such a way that accelerations can still be treated as constant, but guarantee safe operation (see ).","title":"Design Discussions"},{"location":"background/HLD-KeyDesignDecisionsAndAlternatives/#ad-rss-lib-realization","text":"","title":"ad-rss-lib Realization"},{"location":"background/HLD-KeyDesignDecisionsAndAlternatives/#rss-checks-and-response","text":"To check whether the ego vehicle is in a safe state, all the objects in the surrounding must be respected. To do so the ad-rss-lib will perform an analysis against all the objects in the environment individually. Meaning, for each object in the environment the ad-rss-lib will check whether the ego vehicle conflicts with this object. Therefore, longitudinal and lateral checks are performed. As mentioned earlier, these checks are performed separately for each object - ego vehicle pair, i.e. for each situation. At this, the type of situation has to be evaluated upfront outside of this library implementation. Otherwise, this RSS implementation would enforce a concrete representation of the environment and i.e. the map data with lanes, intersections and priority rules. The situations types that have to be identified are: both vehicles drive on the same road in the same direction in opposite direction both vehicles drive on different roads that are connected by an intersection the ego vehicle has priority over the other vehicle the other vehicle has priority over the ego vehicle both vehicles have same priority (no vehicle has priority over the other vehicle)","title":"RSS checks and response"},{"location":"background/HLD-KeyDesignDecisionsAndAlternatives/#situation-based-coordinate-system","text":"As described in the RSS paper in section 3.2 \"Preliminaries \u2014 A Lane-Based Coordinate System\", all RSS calculations are based on a lane-centric coordinate system. This system uses adjacent, straight lanes of constant width, and thus requires a transformation of the object states from Cartesian into the lane space. This transformation into a lane-based coordinate system is described by a bijective function, as pointed out by paper 1. Therein, the lateral position of a vehicle within the lane is mapped to a parametric interval [ -0.5; 0.5 ], where the lane boundaries are fixed at the borders of the interval. The advantage of such a coordinate system over the Cartesian system is that it allows the direct calculation of longitudinal and lateral distances of objects. However, when transforming the Cartesian space into a lane-based coordinate system, several challenges have to be taken into consideration.","title":"Situation-Based Coordinate System"},{"location":"background/HLD-KeyDesignDecisionsAndAlternatives/#summary","text":"Summary RSS checks are performed on the current state on a ego vehicle - object pair basis In dangerous situations only braking maneuvers are issued. RSS does not initiate evasive maneuvers, but will not hinder the driving policy to execute lateral evasive maneuvers, as long as these are compliant with the required RSS response. To handle changing lateral/longitudinal lane geometries when transforming the Cartesian space into the situation based coordinate system, the vehicles position extrema are chosen in such a way that accelerations can still be treated as constant, but guarantee safe operation (see ).","title":"Summary"},{"location":"background/HLD-Safety/","text":"Design for Safety In principle, RSS is implementing safety of the intended functionality (SOTIF). One can apply RSS without general functional safety (FuSa) aspects to safeguard the planning functionality. If RSS is implemented in an ADS with FuSa constraints on system level, RSS contributes to the FuSa goals of the whole ADS.","title":"Safety"},{"location":"background/HLD-Safety/#design-for-safety","text":"In principle, RSS is implementing safety of the intended functionality (SOTIF). One can apply RSS without general functional safety (FuSa) aspects to safeguard the planning functionality. If RSS is implemented in an ADS with FuSa constraints on system level, RSS contributes to the FuSa goals of the whole ADS.","title":"Design for Safety"},{"location":"background/HLD-Security/","text":"Design for Security This chapter discusses security aspects. Architecture and dataflow As a reminder of the high-level architecture, we refer to two figures from the integration chapter . The first figure, shows the RSS function within the autonomous driving (AD) system. The RSS function has a single input called rssWorldModelData , and a single output called rssAccelerationRestrictions . The second figure, shows further detail of the RSS function, with the same external inputs and outputs ( rssWorldModelData and rssAccelerationRestrictions ), as well as the internal calculation steps and internal dataflow. In addition, from the chapter , we refer to the figure describing the RSS Component This figure shows the C++ software class that implements the external RSS interface, called RssCheck . The top-level external interface is implemented using a single routine, called calculateAccelerationRestriction() , which is a member function of the RssCheck class. This routine has a single input, called worldModel (of type WorldModel ), and a single output, called accelerationRestriction (of type AccelerationRestriction ). This figure also shows the subroutines called from RssCheck::calculateAccelerationRestriction() , which are part of the core interface of the library. The library is single-thread, does not make network connections, and does not make connections with other processes remote or local. The library does not make use of any 3rd party components, and as such does not have security dependencies. The primary adversary model is one where invalid/incorrect input data could be provided to the library input interface by the system or from an upstream source. In the following sections, we discuss security aspects related to: input data (implemented by WorldModel ), output data (implemented by AccelerationRestrictions ), and the RSS function itself (implemented by RssCheck and supporting library classes). RSS input data ( WorldModel ) Input data source The input data is contained in WorldModel . This data includes distances to other road agents (vehicles and other) and velocities of other road agents. This data also includes description of the geometry of the road (and road lanes). All data types are described in detail in the chapter . The data contained in WorldModel is provided directly by a calling routine external to the RSS library. Typically, this data will ultimately originate from the vehicle sensing subsystem, but it is the responsibility of the calling routine to receive, convert, and provide this sensing-derived data to the RSS function in the correct format. The calling routine must ensure the integrity of the input data provided to the RSS library functions. Validity of input data and error handling The library attempts to ensure the validity of the input data, and handle cases of improper or invalid input data, in several ways. Several explicit checks of the input data validity are performed, including the following. Check that the data structure describing the local road and lane geometries is internally consistent. The description of a local road follows basic constraints, and if the description is inconsistent with these constraints, the routine that analyzes the situation from the input data returns, with the success/fail flag set to 'fail'. Check that the data structures describing the ego-vehicle or other objects (other vehicles) are internally consistent. The routine that analyzes the situation checks against basic constraints. If the constraints are violated, the routine returns with the success/fail flag set to 'fail'. For this, the routines withinValidInputRange() are used. The respective Doxygen description of these contains the absolute values against which the inputs (like e.g. velocities, accelerations, etc.) are checked. Error handling: Each routine in the library that invokes subroutines checks a success/fail flag returned by the subroutine. In addition, many routines perform custom checking of the internal logic against known constraints of RSS. A failure of a logic check or of a subroutine results in interruption of the routine and a fail flag being passed to the calling routine. Exception handling: The code-blocks in high-level routines are enclosed inside C++ try-catch blocks. Any exception thrown at lower-level software routines results in a fail flag being returned to the caller of the publicly available high-level routines. When any of the above errors occur, the top-level RSS routine, RssCheck::calculateAccelerationRestriction() , will return with the success/fail flag set to 'fail'. Logging: The top-level routine in the library returns a success/fail flag that can be recorded by logging functions that may be available in the overall AD system (external to the library). Beyond this, the library does not perform error logging internally. Non-functional requirements The size of the input data ( WorldModel ) provided to RssCheck is determined by the number of other objects (other vehicles or road agents) that the ego-vehicle is interacting with, and the size of the description of each object and associated road areas. Based on this, it is straightforward to bound the size of data that must be consumed by the RssCheck in a single call, based on the sizes of individual datatypes and by bounding the number of objects. It is the responsibility of the system integrator to determine the number of objects the system can handle and to bound the size of the input data. It is the responsibility of the system integrator to determine an appropriate rate or a maximum rate at which the top-level routine, `RssCheck::calculateAccelerationRestriction(), should be invoked. The latency resulting from the processing time of RssCheck::calculateAccelerationRestriction() should be strictly limited, due to the real-time nature of the AD system and closed-loop interaction with the real world environment. This latency should be less than the time period (1/rate) of the ActuatorSubSystem. It is the responsibility of the system integrator to ensure that this is achieved, or to achieve a latency below an upper bound that is tighter (lower) than the one mentioned here. RSS output data ( AccelerationRestriction ) RssCheck::calculateAccelerationRestriction() outputs a structure of type AccelerationRestriction . This is a very small structure that contains three ranges of acceleration allowed by RSS: allowable range of longitudinal acceleration, allowable range of lateral acceleration to the left of the vehicle, and allowable range of lateral acceleration to the right of the vehicle. Each acceleration range consists of two values: a lower bound and an upper bound. The lower bound and upper bound simply specify an interval of allowable acceleration. Note that a negative value of acceleration implies deceleration, i.e. braking. Output data destination These three ranges (in AccelerationRestriction ) are provided to the system that calls the RSS top-level routine, and indicate the range of acceleration that the AD system must ultimately achieve in order to comply to RSS. In other words, if the AD system seeks to comply to the RSS model, it must achieve an acceleration that is within these bounds provided by the RSS function. Typically, the system would provide the RSS acceleration restriction data to the actuation and control subsystem of the autonomous driving system. This subsystem, external to the RSS library, should enforce the lower and upper bounds of lateral and longitudinal acceleration provided by the RSS function. Implementation of this process is external to the RSS library, and the system integrator must ensure that this is implemented properly and that RSS output values are used correctly. Bounds on the output data values As discussed above, the output values of the RSS function are lower and upper bounds on acceleration. The lower and upper bounds determined by the RSS function originate from the input provided to the RSS function. Namely, acceleration values are provided as dynamics properties of each vehicle acting as road agent/object in the situation. Hence, in the current implementation, the set of possible output data values is a very small set of values that are provided as input. The output values can be further bounded within absolute lower and upper limits by bounding the input values within those desired limits. Also check the Doxygen documentation of the withinValidInputRange() functions of the respective data types for the actual values defined. It is the responsibility of the system external to the RSS library to ensure that the acceleration and deceleration actually achieved by the vehicle always remain within the limits calculated by the RSS function, and remain within other limits unrelated to RSS (e.g. physical limits imposed by the vehicle dynamics and the environment). Bounds on the output data size The output data of the RSS calculations consists of 6 floating point values (3 ranges, each with a lower and upper limit). As such, the size of the output data is strictly bounded already. It is the responsibility of the system integrator to determine an appropriate rate or maximum rate at which to invoke the RSS library function. RSS library code validation Dependencies The RSS library has no dependency on any external library (except for the C++ Standard Library). Coding standards Code quality has been ensured through unit testing. Unit testing achieved code coverage of: 100% functions, 100% lines, 80% branches. Current coverage measures can be retrieved via github deployment: https://intel.github.io/ad-rss-lib/coverage/index.html Compiler and compiler security flags The development platform is Ubuntu Linux 16.04 Xenial. A standard cmake toolchain has been used to compile the library. The compiler is g++ 5.4.0; g++ 4.8.0 is also supported. The following, strict, compilation flags are used: C++11, -Werror, -Wall, -Wextra, -pedantic, -Wconversion, -Wsign-conversion, -Wfloat-equal -Wshadow -Wswitch-default -Wenum-compare -Wformat -Wformat-security. -Werror turns all warnings into errors -Wall enables many warnings about code constructs that are questionable -Wextra enables additional warnings not enabled by -Wall -Wconversion warns for implicit conversions (e.g. between integer and real types) -Wsign-conversion warn for implicit conversions that may alter a value -pedantic issues all warnings demanded by strict ISO C and C++ -Wfloat-equal warn if floating-point values are used in equality comparisons -Wshadow warn on shadowed variable declarations -Wswitch-default warn if the default case is missing in a switch -Wenum-compare warn about a comparison between values of different enumerated types -Wformat* warns about errors within format strings In addition, there are compiler flags * -fstack-protector-all -fasynchronous-unwind-tables -fno-omit-frame-pointer -fno-delete-null-pointer-checks -fno-strict-overflow -fwrapv -fPIE -fPIC -D_FORTIFY_SOURCE=2 and linker flags * -Wl,-z,now -Wl,-z,relro -pie defined to harden the resulting binaries. Hardening is disabled by default, as build hardening is usually injected by the surrounding build system. Compilation with these flags completes without any error or warning. Code analysis The code analysis tool cppcheck was run on the library code, and no relevant issues found. Critical assets The library does not contain critical assets from a security perspective, other than the library code itself.","title":"Security"},{"location":"background/HLD-Security/#design-for-security","text":"This chapter discusses security aspects.","title":"Design for Security"},{"location":"background/HLD-Security/#architecture-and-dataflow","text":"As a reminder of the high-level architecture, we refer to two figures from the integration chapter . The first figure, shows the RSS function within the autonomous driving (AD) system. The RSS function has a single input called rssWorldModelData , and a single output called rssAccelerationRestrictions . The second figure, shows further detail of the RSS function, with the same external inputs and outputs ( rssWorldModelData and rssAccelerationRestrictions ), as well as the internal calculation steps and internal dataflow. In addition, from the chapter , we refer to the figure describing the RSS Component This figure shows the C++ software class that implements the external RSS interface, called RssCheck . The top-level external interface is implemented using a single routine, called calculateAccelerationRestriction() , which is a member function of the RssCheck class. This routine has a single input, called worldModel (of type WorldModel ), and a single output, called accelerationRestriction (of type AccelerationRestriction ). This figure also shows the subroutines called from RssCheck::calculateAccelerationRestriction() , which are part of the core interface of the library. The library is single-thread, does not make network connections, and does not make connections with other processes remote or local. The library does not make use of any 3rd party components, and as such does not have security dependencies. The primary adversary model is one where invalid/incorrect input data could be provided to the library input interface by the system or from an upstream source. In the following sections, we discuss security aspects related to: input data (implemented by WorldModel ), output data (implemented by AccelerationRestrictions ), and the RSS function itself (implemented by RssCheck and supporting library classes).","title":"Architecture and dataflow"},{"location":"background/HLD-Security/#rss-input-data-worldmodel","text":"","title":"RSS input data (WorldModel)"},{"location":"background/HLD-Security/#rss-output-data-accelerationrestriction","text":"RssCheck::calculateAccelerationRestriction() outputs a structure of type AccelerationRestriction . This is a very small structure that contains three ranges of acceleration allowed by RSS: allowable range of longitudinal acceleration, allowable range of lateral acceleration to the left of the vehicle, and allowable range of lateral acceleration to the right of the vehicle. Each acceleration range consists of two values: a lower bound and an upper bound. The lower bound and upper bound simply specify an interval of allowable acceleration. Note that a negative value of acceleration implies deceleration, i.e. braking.","title":"RSS output data (AccelerationRestriction)"},{"location":"background/HLD-Security/#rss-library-code-validation","text":"","title":"RSS library code validation"},{"location":"background/Overview/","text":"Overview Introduction The Responsibility-Sensitive Safety (RSS) model is designed to formalize and contextualize human judgment regarding all multi-agent driving situations and dilemmas. RSS formalizes terms like dangerous situations, proper response and notion of blame in a mathematical way. From planning and decision-making perspective, RSS ensures that the AD system will not issue a command that would lead to an accident. RSS Summary RSS as described here , can be summarized as follows: RSS continuously monitors the current state of the environment, in order to determine if the ego vehicle is currently in a safe state. If the ego vehicle is not in a safe state, RSS will provide a response action that will bring the car back into a safe state. As a result, in case of an accident, the ego vehicle cannot be blamed responsible, as it was not causing the collision. A state is regarded as safe , if the ego vehicle is not causing a collision with another object, under the worst case assumption that the ego vehicle will accelerate (depending on the situation this can be also a deceleration) at maximum possible speed during its response time. Hence, RSS does not take the output of the driving policy into account. However, as RSS uses worst case assumption on reaction time, acceleration etc., it is guaranteed that, no valid action of the driving policy can bring the vehicle into an unsafe state, if RSS regards the current situation as safe. If the ego vehicle is in a dangerous situation, RSS will assure a proper reaction, that will bring the car back into a safe state. Therefore, it will impose proper restrictions for the longitudinal and lateral accelerations of the driving command, that is send to the ego vehicle. Note that this will assure that the vehicle reacts correctly, but the driving policy still has the chance to solve the dangerous situation on a more elaborate way, as long as the desired action is within the RSS limits. The reason is that RSS has only basic information about the environment, whereas the driving policy can use much more information, and is able to perform much more sophisticated path finding strategies. RSS differentiates between longitudinal and lateral conflicts. A longitudinal conflict means that the distance between the ego vehicle and an object in front or in the back of the ego vehicle is smaller than the longitudinal safety distance. Similarly, a lateral conflict arises, if the distance to the left or right of the ego vehicle to another object is less than the required lateral safety margin. Depending on the type of conflict, RSS requires a different response. In addition, RSS differentiates between normal (single- or multi-lane) roads, intersections and unstructured roads (e.g. parking areas). Depending on the type of road, the required response for a conflict is different. Objects are classified into Vulnerable Road Users (e.g. pedestrians) and other (dynamic) traffic objects. The reason for this separation is that the first object group requires special safety considerations, as for example pedestrians may have unknown routes, compared to vehicles. RSS is not about: How to get \"good enough\" sensor data. It is about the usage, which may impose some sensor requirements. Avoiding collisions, if other traffic participants show a completely erratic driving behavior. Instead, it is about ensuring that the ego vehicle cannot be blamed for the accident. Purpose and Scope of this Library The design of the library at hand is based on the academic paper \"On a Formal Model of Safe and Scalable Self-driving Cars\" . The library provides a C++ implementation of RSS according to the aforementioned summary. The key component of this implementation is called \"ad-rss-lib\" . This library receives (post-processed) sensor information and provides actuator command restrictions as output. ad-rss-lib (implemented in the library) and its interfaces to the outside world In summary, the ad-rss-lib receives an object list, with information about all objects in the surrounding environment of the ego vehicle. Then, the ad-rss-lib creates an object - ego vehicle pair, for each object. This pair is usually referred to as \"Situation\" . For all situations, the aforementioned RSS checks are performed and a proper response is calculated. Finally, one overall response is computed by the ad-rss-lib, and the corresponding actuator command restrictions (i.e. lateral and longitudinal acceleration restrictions) are sent out. Note The conversion from sensor data to the object list required by the ad-rss-lib, as well as the conversion of the actuator command restrictions to real driving commands, have to be implemented by the user of this library, as these parts heavily depend on the actual vehicle setup. Note The current scope of the provided implementation is: Standalone C++-library containing the implementation of the ad-rss-lib The ad-rss-lib covers multi-lane roads and intersections Code quality is assured by automated testing with test coverage of 100% on methods and 80% on branches as well as static code analysis The library is intended for the research community.","title":"Overview"},{"location":"background/Overview/#introduction","text":"The Responsibility-Sensitive Safety (RSS) model is designed to formalize and contextualize human judgment regarding all multi-agent driving situations and dilemmas. RSS formalizes terms like dangerous situations, proper response and notion of blame in a mathematical way. From planning and decision-making perspective, RSS ensures that the AD system will not issue a command that would lead to an accident.","title":"Introduction"},{"location":"background/Overview/#rss-summary","text":"RSS as described here , can be summarized as follows: RSS continuously monitors the current state of the environment, in order to determine if the ego vehicle is currently in a safe state. If the ego vehicle is not in a safe state, RSS will provide a response action that will bring the car back into a safe state. As a result, in case of an accident, the ego vehicle cannot be blamed responsible, as it was not causing the collision. A state is regarded as safe , if the ego vehicle is not causing a collision with another object, under the worst case assumption that the ego vehicle will accelerate (depending on the situation this can be also a deceleration) at maximum possible speed during its response time. Hence, RSS does not take the output of the driving policy into account. However, as RSS uses worst case assumption on reaction time, acceleration etc., it is guaranteed that, no valid action of the driving policy can bring the vehicle into an unsafe state, if RSS regards the current situation as safe. If the ego vehicle is in a dangerous situation, RSS will assure a proper reaction, that will bring the car back into a safe state. Therefore, it will impose proper restrictions for the longitudinal and lateral accelerations of the driving command, that is send to the ego vehicle. Note that this will assure that the vehicle reacts correctly, but the driving policy still has the chance to solve the dangerous situation on a more elaborate way, as long as the desired action is within the RSS limits. The reason is that RSS has only basic information about the environment, whereas the driving policy can use much more information, and is able to perform much more sophisticated path finding strategies. RSS differentiates between longitudinal and lateral conflicts. A longitudinal conflict means that the distance between the ego vehicle and an object in front or in the back of the ego vehicle is smaller than the longitudinal safety distance. Similarly, a lateral conflict arises, if the distance to the left or right of the ego vehicle to another object is less than the required lateral safety margin. Depending on the type of conflict, RSS requires a different response. In addition, RSS differentiates between normal (single- or multi-lane) roads, intersections and unstructured roads (e.g. parking areas). Depending on the type of road, the required response for a conflict is different. Objects are classified into Vulnerable Road Users (e.g. pedestrians) and other (dynamic) traffic objects. The reason for this separation is that the first object group requires special safety considerations, as for example pedestrians may have unknown routes, compared to vehicles. RSS is not about: How to get \"good enough\" sensor data. It is about the usage, which may impose some sensor requirements. Avoiding collisions, if other traffic participants show a completely erratic driving behavior. Instead, it is about ensuring that the ego vehicle cannot be blamed for the accident.","title":"RSS Summary"},{"location":"background/Overview/#purpose-and-scope-of-this-library","text":"The design of the library at hand is based on the academic paper \"On a Formal Model of Safe and Scalable Self-driving Cars\" . The library provides a C++ implementation of RSS according to the aforementioned summary. The key component of this implementation is called \"ad-rss-lib\" . This library receives (post-processed) sensor information and provides actuator command restrictions as output. ad-rss-lib (implemented in the library) and its interfaces to the outside world In summary, the ad-rss-lib receives an object list, with information about all objects in the surrounding environment of the ego vehicle. Then, the ad-rss-lib creates an object - ego vehicle pair, for each object. This pair is usually referred to as \"Situation\" . For all situations, the aforementioned RSS checks are performed and a proper response is calculated. Finally, one overall response is computed by the ad-rss-lib, and the corresponding actuator command restrictions (i.e. lateral and longitudinal acceleration restrictions) are sent out. Note The conversion from sensor data to the object list required by the ad-rss-lib, as well as the conversion of the actuator command restrictions to real driving commands, have to be implemented by the user of this library, as these parts heavily depend on the actual vehicle setup. Note The current scope of the provided implementation is: Standalone C++-library containing the implementation of the ad-rss-lib The ad-rss-lib covers multi-lane roads and intersections Code quality is assured by automated testing with test coverage of 100% on methods and 80% on branches as well as static code analysis The library is intended for the research community.","title":"Purpose and Scope of this Library"},{"location":"background/SupportedRssFeatures/","text":"Release 1.x The release versions 1.x cover the complete feature set of RSS as described here , except: Compensating for improper behavior of others Lateral conflicts in case of intersections Respecting occlusions Checks with Vulnerable Road Users Checks for unstructured roads, e.g. parking spaces","title":"Supported RSS Features"},{"location":"background/SupportedRssFeatures/#release-1x","text":"The release versions 1.x cover the complete feature set of RSS as described here , except: Compensating for improper behavior of others Lateral conflicts in case of intersections Respecting occlusions Checks with Vulnerable Road Users Checks for unstructured roads, e.g. parking spaces","title":"Release 1.x"}]}